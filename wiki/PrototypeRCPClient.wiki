#summary Description of RCP Client

= Introduction =
A first RCP client is available in the prototype directory, the source can be found here:
  * http://socialmusicdiscovery.googlecode.com/svn/prototypes/ClientRCP/

Brief instructions on what you need to do to get it running is available in the Readme-file:
  * http://socialmusicdiscovery.googlecode.com/svn/prototypes/ClientRCP/ReadMe.txt

= "Roadmap" =
Well, not really, but a few words on what I think needs to be done to bring this thing out of the prototype folder and let us start widening scope and honing details:
  # (done) _Main menu and popup menus declared thru extension points (not in code)_
  # (done) _A wrapping layer to make SMD entities observable and "self-inflating"
  # A decent navigator (probably !ExpandBar)
  # Observable label providers in grids
  # Restructured plug-ins (as outlined below)
  # A head-less builder (e.g. Maven or Buckminster)
  # A bootstrap to deploy the basic client (e.g. JWS)
  # An update site where we can upload new versions of the plug-ins
  # Enrich the core editors (Release and Artist)

Effective time, this would all take a couple of weeks or so. Working odd hours around midnight ... I'm not so sure :-(

= Design Guidelines =
Some brief and preliminary thoughts on the design principles for the RCP client. Comments expected and welcome!

  * JFace 
    * JFace offers a convenience layer on top of SWT, making it much easier to work with. Application code should rarely touch an SWT component directly.
    * JFace data binding is perhaps the most important discriminator to separate a rich client from a thin. We bind widgets to properties using data binding, and we use observable label providers in grids. 
  * Menus, Actions and Commands
    * Menu items (both main and popup) are primarily declared thru extension points, not attached directly to viewers. This makes common commands universally available; whenever and wherever an Artist is selected, a menu with all applicable Artist commands is available.
    * Actions vs. Commands - Commands are "new school" and more powerful, Actions are "old school" and less powerful. However, the command framework is pretty abstract and - to most people - confusing. We should use Commands to define  "global" actions that we bind to keyboard shortcuts, but we use regular Actions and Runnables where a Command isn't required.
  * Nebula - if we want to stay RAP-compatible, we can probably *not* use any Nebula components. In time, we may offer alternative implementations (RCP vs RAP). If we ignore RAP compliance, these Nebula components would be of particular interest:
    * Grid - the Nebula grid offers most of the features that the standard Eclipse Tables and Trees lack. All lists, trees and tables could be replaced by the grid.
    * PShelf - could replace !ExpandBar as the primary navigation widget.
  * UI Style and "Skins"
    * Now (Eclipse 3.x): we run with the default appearance produced by the Forms Toolkit. 
    * Then (Eclipse 4): we use the new (CSS-oriented) way of styling the application. It is too much work to do that using the current platform (3.6).
  * Target platform - a pre-configured RCP target platform will be checked into SVN. This includes the RCP base framework and all desired plug-ins to avoid the dependency on individual installations.
  * Plug-in Component structure - we separate the client in a few main parts. The basic idea is to have a small base product that is easily installed and rarely updated, and to use an update site to maintain the other components.
    * Installer - an almost empty "bootstrap" to allow installation/update of other components from update site
    *: Splash screens, intro pages, etc
    * Product - splash screens, license, intro pages, etc
    * Foundation - fundamental UI components; custom widgets, utils, common abstractions, ...
    * Server Connection (Data Source) - abstracts the server facade and produces UI-friendly objects (lazily loaded, observable, named ...)
    * UI plugins:
      * Navigator UI - A PShelf presentation of "shallow" objects, with the ability to "inflate" any object and open an editor on it
      * Core model editors - EditorPart subclasses that operate on SMDEntity instances from the core model
      * Subjective model editors - EditorPart subclasses that operate on SMD instances from the subjective model
  

= External Links =
  * SWT Designer (part of !WindowBuilder PRO)
    * http://code.google.com/javadevtools/wbpro/installation/updatesite_3.6.html
    * update site: http://dl.google.com/eclipse/inst/d2wbpro/latest/3.6 - you probably need to ignore one security warning.

 * Eclipse snippets, examples and tutorials:
   * RCP:
     * http://www.vogella.de/articles/EclipseRCP/article.html
   * JFace:
     * http://wiki.eclipse.org/JFace_Data_Binding/Snippets#Running_the_Snippets
     * http://wiki.eclipse.org/index.php/JFaceSnippets
   * SWT:
     * http://www.eclipse.org/swt/snippets/
     * http://www.eclipse.org/swt/examples.php
    
  * Eclipse Integration for Apache Maven (IAM)
    * http://www.eclipse.org/iam 
    * Update site: http://q4e.googlecode.com/svn/trunk/updatesite-iam